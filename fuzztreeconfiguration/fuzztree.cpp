// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include <fuzztree.h>

namespace fuzztree
{
  // AnnotatedElement
  // 

  const AnnotatedElement::AnnotationsSequence& AnnotatedElement::
  annotations () const
  {
    return this->annotations_;
  }

  AnnotatedElement::AnnotationsSequence& AnnotatedElement::
  annotations ()
  {
    return this->annotations_;
  }

  void AnnotatedElement::
  annotations (const AnnotationsSequence& s)
  {
    this->annotations_ = s;
  }

  const AnnotatedElement::IdType& AnnotatedElement::
  id () const
  {
    return this->id_.get ();
  }

  AnnotatedElement::IdType& AnnotatedElement::
  id ()
  {
    return this->id_.get ();
  }

  void AnnotatedElement::
  id (const IdType& x)
  {
    this->id_.set (x);
  }

  void AnnotatedElement::
  id (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const AnnotatedElement::NameOptional& AnnotatedElement::
  name () const
  {
    return this->name_;
  }

  AnnotatedElement::NameOptional& AnnotatedElement::
  name ()
  {
    return this->name_;
  }

  void AnnotatedElement::
  name (const NameType& x)
  {
    this->name_.set (x);
  }

  void AnnotatedElement::
  name (const NameOptional& x)
  {
    this->name_ = x;
  }

  void AnnotatedElement::
  name (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // Model
  // 


  // FuzzTree
  // 

  const FuzzTree::TopEventType& FuzzTree::
  topEvent () const
  {
    return this->topEvent_.get ();
  }

  FuzzTree::TopEventType& FuzzTree::
  topEvent ()
  {
    return this->topEvent_.get ();
  }

  void FuzzTree::
  topEvent (const TopEventType& x)
  {
    this->topEvent_.set (x);
  }

  void FuzzTree::
  topEvent (::std::auto_ptr< TopEventType > x)
  {
    this->topEvent_.set (x);
  }


  // Node_base
  // 

  const Node_base::ChildrenSequence& Node_base::
  children () const
  {
    return this->children_;
  }

  Node_base::ChildrenSequence& Node_base::
  children ()
  {
    return this->children_;
  }

  void Node_base::
  children (const ChildrenSequence& s)
  {
    this->children_ = s;
  }

  const Node_base::XOptional& Node_base::
  x () const
  {
    return this->x_;
  }

  Node_base::XOptional& Node_base::
  x ()
  {
    return this->x_;
  }

  void Node_base::
  x (const XType& x)
  {
    this->x_.set (x);
  }

  void Node_base::
  x (const XOptional& x)
  {
    this->x_ = x;
  }

  const Node_base::YOptional& Node_base::
  y () const
  {
    return this->y_;
  }

  Node_base::YOptional& Node_base::
  y ()
  {
    return this->y_;
  }

  void Node_base::
  y (const YType& x)
  {
    this->y_.set (x);
  }

  void Node_base::
  y (const YOptional& x)
  {
    this->y_ = x;
  }


  // ChildNode_base
  // 


  // Gate_base
  // 


  // VariationPoint_base
  // 


  // InclusionVariationPoint
  // 

  const InclusionVariationPoint::OptionalType& InclusionVariationPoint::
  optional () const
  {
    return this->optional_.get ();
  }

  InclusionVariationPoint::OptionalType& InclusionVariationPoint::
  optional ()
  {
    return this->optional_.get ();
  }

  void InclusionVariationPoint::
  optional (const OptionalType& x)
  {
    this->optional_.set (x);
  }

  InclusionVariationPoint::OptionalType InclusionVariationPoint::
  optionalDefaultValue ()
  {
    return OptionalType (false);
  }

  const InclusionVariationPoint::CostsOptional& InclusionVariationPoint::
  costs () const
  {
    return this->costs_;
  }

  InclusionVariationPoint::CostsOptional& InclusionVariationPoint::
  costs ()
  {
    return this->costs_;
  }

  void InclusionVariationPoint::
  costs (const CostsType& x)
  {
    this->costs_.set (x);
  }

  void InclusionVariationPoint::
  costs (const CostsOptional& x)
  {
    this->costs_ = x;
  }


  // BasicEvent_base
  // 

  const BasicEvent_base::ProbabilityType& BasicEvent_base::
  probability () const
  {
    return this->probability_.get ();
  }

  BasicEvent_base::ProbabilityType& BasicEvent_base::
  probability ()
  {
    return this->probability_.get ();
  }

  void BasicEvent_base::
  probability (const ProbabilityType& x)
  {
    this->probability_.set (x);
  }

  void BasicEvent_base::
  probability (::std::auto_ptr< ProbabilityType > x)
  {
    this->probability_.set (x);
  }


  // TopEvent_base
  // 

  const TopEvent_base::MissionTimeType& TopEvent_base::
  missionTime () const
  {
    return this->missionTime_.get ();
  }

  TopEvent_base::MissionTimeType& TopEvent_base::
  missionTime ()
  {
    return this->missionTime_.get ();
  }

  void TopEvent_base::
  missionTime (const MissionTimeType& x)
  {
    this->missionTime_.set (x);
  }


  // And_base
  // 


  // Or_base
  // 


  // Xor_base
  // 


  // VotingOr_base
  // 

  const VotingOr_base::KType& VotingOr_base::
  k () const
  {
    return this->k_.get ();
  }

  VotingOr_base::KType& VotingOr_base::
  k ()
  {
    return this->k_.get ();
  }

  void VotingOr_base::
  k (const KType& x)
  {
    this->k_.set (x);
  }


  // FeatureVariationPoint_base
  // 


  // RedundancyVariationPoint_base
  // 

  const RedundancyVariationPoint_base::StartType& RedundancyVariationPoint_base::
  start () const
  {
    return this->start_.get ();
  }

  RedundancyVariationPoint_base::StartType& RedundancyVariationPoint_base::
  start ()
  {
    return this->start_.get ();
  }

  void RedundancyVariationPoint_base::
  start (const StartType& x)
  {
    this->start_.set (x);
  }

  const RedundancyVariationPoint_base::EndType& RedundancyVariationPoint_base::
  end () const
  {
    return this->end_.get ();
  }

  RedundancyVariationPoint_base::EndType& RedundancyVariationPoint_base::
  end ()
  {
    return this->end_.get ();
  }

  void RedundancyVariationPoint_base::
  end (const EndType& x)
  {
    this->end_.set (x);
  }

  const RedundancyVariationPoint_base::FormulaType& RedundancyVariationPoint_base::
  formula () const
  {
    return this->formula_.get ();
  }

  RedundancyVariationPoint_base::FormulaType& RedundancyVariationPoint_base::
  formula ()
  {
    return this->formula_.get ();
  }

  void RedundancyVariationPoint_base::
  formula (const FormulaType& x)
  {
    this->formula_.set (x);
  }

  void RedundancyVariationPoint_base::
  formula (::std::auto_ptr< FormulaType > x)
  {
    this->formula_.set (x);
  }

  const RedundancyVariationPoint_base::CostFormulaOptional& RedundancyVariationPoint_base::
  costFormula () const
  {
    return this->costFormula_;
  }

  RedundancyVariationPoint_base::CostFormulaOptional& RedundancyVariationPoint_base::
  costFormula ()
  {
    return this->costFormula_;
  }

  void RedundancyVariationPoint_base::
  costFormula (const CostFormulaType& x)
  {
    this->costFormula_.set (x);
  }

  void RedundancyVariationPoint_base::
  costFormula (const CostFormulaOptional& x)
  {
    this->costFormula_ = x;
  }

  void RedundancyVariationPoint_base::
  costFormula (::std::auto_ptr< CostFormulaType > x)
  {
    this->costFormula_.set (x);
  }


  // TransferIn
  // 

  const TransferIn::FromModelIdType& TransferIn::
  fromModelId () const
  {
    return this->fromModelId_.get ();
  }

  TransferIn::FromModelIdType& TransferIn::
  fromModelId ()
  {
    return this->fromModelId_.get ();
  }

  void TransferIn::
  fromModelId (const FromModelIdType& x)
  {
    this->fromModelId_.set (x);
  }

  const TransferIn::MaxCostsType& TransferIn::
  maxCosts () const
  {
    return this->maxCosts_.get ();
  }

  TransferIn::MaxCostsType& TransferIn::
  maxCosts ()
  {
    return this->maxCosts_.get ();
  }

  void TransferIn::
  maxCosts (const MaxCostsType& x)
  {
    this->maxCosts_.set (x);
  }

  TransferIn::MaxCostsType TransferIn::
  maxCostsDefaultValue ()
  {
    return MaxCostsType (0);
  }


  // Annotation
  // 


  // Probability
  // 


  // CrispProbability
  // 

  const CrispProbability::ValueType& CrispProbability::
  value () const
  {
    return this->value_.get ();
  }

  CrispProbability::ValueType& CrispProbability::
  value ()
  {
    return this->value_.get ();
  }

  void CrispProbability::
  value (const ValueType& x)
  {
    this->value_.set (x);
  }


  // FailureRate
  // 

  const FailureRate::ValueType& FailureRate::
  value () const
  {
    return this->value_.get ();
  }

  FailureRate::ValueType& FailureRate::
  value ()
  {
    return this->value_.get ();
  }

  void FailureRate::
  value (const ValueType& x)
  {
    this->value_.set (x);
  }


  // TriangularFuzzyInterval
  // 

  const TriangularFuzzyInterval::AType& TriangularFuzzyInterval::
  a () const
  {
    return this->a_.get ();
  }

  TriangularFuzzyInterval::AType& TriangularFuzzyInterval::
  a ()
  {
    return this->a_.get ();
  }

  void TriangularFuzzyInterval::
  a (const AType& x)
  {
    this->a_.set (x);
  }

  const TriangularFuzzyInterval::B1Type& TriangularFuzzyInterval::
  b1 () const
  {
    return this->b1_.get ();
  }

  TriangularFuzzyInterval::B1Type& TriangularFuzzyInterval::
  b1 ()
  {
    return this->b1_.get ();
  }

  void TriangularFuzzyInterval::
  b1 (const B1Type& x)
  {
    this->b1_.set (x);
  }

  const TriangularFuzzyInterval::B2Type& TriangularFuzzyInterval::
  b2 () const
  {
    return this->b2_.get ();
  }

  TriangularFuzzyInterval::B2Type& TriangularFuzzyInterval::
  b2 ()
  {
    return this->b2_.get ();
  }

  void TriangularFuzzyInterval::
  b2 (const B2Type& x)
  {
    this->b2_.set (x);
  }

  const TriangularFuzzyInterval::CType& TriangularFuzzyInterval::
  c () const
  {
    return this->c_.get ();
  }

  TriangularFuzzyInterval::CType& TriangularFuzzyInterval::
  c ()
  {
    return this->c_.get ();
  }

  void TriangularFuzzyInterval::
  c (const CType& x)
  {
    this->c_.set (x);
  }


  // UndevelopedEvent_base
  // 


  // IntermediateEvent_base
  // 


  // BasicEventSet
  // 

  const BasicEventSet::QuantityOptional& BasicEventSet::
  quantity () const
  {
    return this->quantity_;
  }

  BasicEventSet::QuantityOptional& BasicEventSet::
  quantity ()
  {
    return this->quantity_;
  }

  void BasicEventSet::
  quantity (const QuantityType& x)
  {
    this->quantity_.set (x);
  }

  void BasicEventSet::
  quantity (const QuantityOptional& x)
  {
    this->quantity_ = x;
  }


  // HouseEvent_base
  // 


  // IntermediateEventSet_base
  // 

  const IntermediateEventSet_base::QuantityOptional& IntermediateEventSet_base::
  quantity () const
  {
    return this->quantity_;
  }

  IntermediateEventSet_base::QuantityOptional& IntermediateEventSet_base::
  quantity ()
  {
    return this->quantity_;
  }

  void IntermediateEventSet_base::
  quantity (const QuantityType& x)
  {
    this->quantity_.set (x);
  }

  void IntermediateEventSet_base::
  quantity (const QuantityOptional& x)
  {
    this->quantity_ = x;
  }


  // EventSet
  // 

  const EventSet::QuantityOptional& EventSet::
  quantity () const
  {
    return this->quantity_;
  }

  EventSet::QuantityOptional& EventSet::
  quantity ()
  {
    return this->quantity_;
  }

  void EventSet::
  quantity (const QuantityType& x)
  {
    this->quantity_.set (x);
  }

  void EventSet::
  quantity (const QuantityOptional& x)
  {
    this->quantity_ = x;
  }


  // DecomposedFuzzyProbability
  // 

  const DecomposedFuzzyProbability::AlphaCutsSequence& DecomposedFuzzyProbability::
  alphaCuts () const
  {
    return this->alphaCuts_;
  }

  DecomposedFuzzyProbability::AlphaCutsSequence& DecomposedFuzzyProbability::
  alphaCuts ()
  {
    return this->alphaCuts_;
  }

  void DecomposedFuzzyProbability::
  alphaCuts (const AlphaCutsSequence& s)
  {
    this->alphaCuts_ = s;
  }


  // DoubleToIntervalMap
  // 

  const DoubleToIntervalMap::ValueType& DoubleToIntervalMap::
  value () const
  {
    return this->value_.get ();
  }

  DoubleToIntervalMap::ValueType& DoubleToIntervalMap::
  value ()
  {
    return this->value_.get ();
  }

  void DoubleToIntervalMap::
  value (const ValueType& x)
  {
    this->value_.set (x);
  }

  void DoubleToIntervalMap::
  value (::std::auto_ptr< ValueType > x)
  {
    this->value_.set (x);
  }

  const DoubleToIntervalMap::KeyType& DoubleToIntervalMap::
  key () const
  {
    return this->key_.get ();
  }

  DoubleToIntervalMap::KeyType& DoubleToIntervalMap::
  key ()
  {
    return this->key_.get ();
  }

  void DoubleToIntervalMap::
  key (const KeyType& x)
  {
    this->key_.set (x);
  }


  // Interval
  // 

  const Interval::LowerBoundType& Interval::
  lowerBound () const
  {
    return this->lowerBound_.get ();
  }

  Interval::LowerBoundType& Interval::
  lowerBound ()
  {
    return this->lowerBound_.get ();
  }

  void Interval::
  lowerBound (const LowerBoundType& x)
  {
    this->lowerBound_.set (x);
  }

  const Interval::UpperBoundType& Interval::
  upperBound () const
  {
    return this->upperBound_.get ();
  }

  Interval::UpperBoundType& Interval::
  upperBound ()
  {
    return this->upperBound_.get ();
  }

  void Interval::
  upperBound (const UpperBoundType& x)
  {
    this->upperBound_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace fuzztree
{
  // AnnotatedElement
  //

  AnnotatedElement::
  AnnotatedElement (const IdType& id)
  : ::xml_schema::Type (),
    annotations_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  AnnotatedElement::
  AnnotatedElement (const AnnotatedElement& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    annotations_ (x.annotations_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  AnnotatedElement::
  AnnotatedElement (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    annotations_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void AnnotatedElement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // annotations
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "annotations",
            "",
            &::xsd::cxx::tree::factory_impl< AnnotationsType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< AnnotationsType > r (
            dynamic_cast< AnnotationsType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->annotations_.push_back (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  AnnotatedElement* AnnotatedElement::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AnnotatedElement (*this, f, c);
  }

  AnnotatedElement::
  ~AnnotatedElement ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AnnotatedElement >
  _xsd_AnnotatedElement_type_factory_init (
    "AnnotatedElement",
    "net.fuzztree");

  // Model
  //

  Model::
  Model (const IdType& id)
  : ::fuzztree::AnnotatedElement (id)
  {
  }

  Model::
  Model (const Model& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::fuzztree::AnnotatedElement (x, f, c)
  {
  }

  Model::
  Model (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::fuzztree::AnnotatedElement (e, f, c)
  {
  }

  Model* Model::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Model (*this, f, c);
  }

  Model::
  ~Model ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Model >
  _xsd_Model_type_factory_init (
    "Model",
    "net.fuzztree");

  // FuzzTree
  //

  FuzzTree::
  FuzzTree (const IdType& id,
            const TopEventType& topEvent)
  : ::fuzztree::Model (id),
    topEvent_ (topEvent, ::xml_schema::Flags (), this)
  {
  }

  FuzzTree::
  FuzzTree (const IdType& id,
            ::std::auto_ptr< TopEventType >& topEvent)
  : ::fuzztree::Model (id),
    topEvent_ (topEvent, ::xml_schema::Flags (), this)
  {
  }

  FuzzTree::
  FuzzTree (const FuzzTree& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fuzztree::Model (x, f, c),
    topEvent_ (x.topEvent_, f, this)
  {
  }

  FuzzTree::
  FuzzTree (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fuzztree::Model (e, f | ::xml_schema::Flags::base, c),
    topEvent_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void FuzzTree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::Model::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // topEvent
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "topEvent",
            "",
            &::xsd::cxx::tree::factory_impl< TopEventType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!topEvent_.present ())
          {
            ::std::auto_ptr< TopEventType > r (
              dynamic_cast< TopEventType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->topEvent_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!topEvent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "topEvent",
        "");
    }
  }

  FuzzTree* FuzzTree::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FuzzTree (*this, f, c);
  }

  FuzzTree::
  ~FuzzTree ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, FuzzTree >
  _xsd_FuzzTree_type_factory_init (
    "FuzzTree",
    "net.fuzztree");

  // Node_base
  //

  Node_base::
  Node_base (const IdType& id)
  : ::fuzztree::AnnotatedElement (id),
    children_ (::xml_schema::Flags (), this),
    x_ (::xml_schema::Flags (), this),
    y_ (::xml_schema::Flags (), this)
  {
  }

  Node_base::
  Node_base (const Node_base& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fuzztree::AnnotatedElement (x, f, c),
    children_ (x.children_, f, this),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  Node_base::
  Node_base (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fuzztree::AnnotatedElement (e, f | ::xml_schema::Flags::base, c),
    children_ (f, this),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Node_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::AnnotatedElement::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // children
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "children",
            "",
            &::xsd::cxx::tree::factory_impl< ChildrenType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< ChildrenType > r (
            dynamic_cast< ChildrenType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->children_.push_back (r);
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (XTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (YTraits::create (i, f, this));
        continue;
      }
    }
  }

  Node_base* Node_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Node_base (*this, f, c);
  }

  Node_base::
  ~Node_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Node >
  _xsd_Node_type_factory_init (
    "Node",
    "net.fuzztree");

  // ChildNode_base
  //

  ChildNode_base::
  ChildNode_base (const IdType& id)
  : ::fuzztree::Node (id)
  {
  }

  ChildNode_base::
  ChildNode_base (const ChildNode_base& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::fuzztree::Node (x, f, c)
  {
  }

  ChildNode_base::
  ChildNode_base (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::fuzztree::Node (e, f, c)
  {
  }

  ChildNode_base* ChildNode_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChildNode_base (*this, f, c);
  }

  ChildNode_base::
  ~ChildNode_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ChildNode >
  _xsd_ChildNode_type_factory_init (
    "ChildNode",
    "net.fuzztree");

  // Gate_base
  //

  Gate_base::
  Gate_base (const IdType& id)
  : ::fuzztree::ChildNode (id)
  {
  }

  Gate_base::
  Gate_base (const Gate_base& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fuzztree::ChildNode (x, f, c)
  {
  }

  Gate_base::
  Gate_base (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fuzztree::ChildNode (e, f, c)
  {
  }

  Gate_base* Gate_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Gate_base (*this, f, c);
  }

  Gate_base::
  ~Gate_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Gate >
  _xsd_Gate_type_factory_init (
    "Gate",
    "net.fuzztree");

  // VariationPoint_base
  //

  VariationPoint_base::
  VariationPoint_base (const IdType& id)
  : ::fuzztree::ChildNode (id)
  {
  }

  VariationPoint_base::
  VariationPoint_base (const VariationPoint_base& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::fuzztree::ChildNode (x, f, c)
  {
  }

  VariationPoint_base::
  VariationPoint_base (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::fuzztree::ChildNode (e, f, c)
  {
  }

  VariationPoint_base* VariationPoint_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VariationPoint_base (*this, f, c);
  }

  VariationPoint_base::
  ~VariationPoint_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VariationPoint >
  _xsd_VariationPoint_type_factory_init (
    "VariationPoint",
    "net.fuzztree");

  // InclusionVariationPoint
  //

  InclusionVariationPoint::
  InclusionVariationPoint (const IdType& id)
  : ::fuzztree::VariationPoint (id),
    optional_ (optionalDefaultValue (), ::xml_schema::Flags (), this),
    costs_ (::xml_schema::Flags (), this)
  {
  }

  InclusionVariationPoint::
  InclusionVariationPoint (const InclusionVariationPoint& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::fuzztree::VariationPoint (x, f, c),
    optional_ (x.optional_, f, this),
    costs_ (x.costs_, f, this)
  {
  }

  InclusionVariationPoint::
  InclusionVariationPoint (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::fuzztree::VariationPoint (e, f | ::xml_schema::Flags::base, c),
    optional_ (f, this),
    costs_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void InclusionVariationPoint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::VariationPoint::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "optional" && n.namespace_ ().empty ())
      {
        this->optional_.set (OptionalTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "costs" && n.namespace_ ().empty ())
      {
        this->costs_.set (CostsTraits::create (i, f, this));
        continue;
      }
    }

    if (!optional_.present ())
    {
      this->optional_.set (optionalDefaultValue ());
    }
  }

  InclusionVariationPoint* InclusionVariationPoint::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InclusionVariationPoint (*this, f, c);
  }

  InclusionVariationPoint::
  ~InclusionVariationPoint ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InclusionVariationPoint >
  _xsd_InclusionVariationPoint_type_factory_init (
    "InclusionVariationPoint",
    "net.fuzztree");

  // BasicEvent_base
  //

  BasicEvent_base::
  BasicEvent_base (const IdType& id,
                   const ProbabilityType& probability)
  : ::fuzztree::InclusionVariationPoint (id),
    probability_ (probability, ::xml_schema::Flags (), this)
  {
  }

  BasicEvent_base::
  BasicEvent_base (const IdType& id,
                   ::std::auto_ptr< ProbabilityType >& probability)
  : ::fuzztree::InclusionVariationPoint (id),
    probability_ (probability, ::xml_schema::Flags (), this)
  {
  }

  BasicEvent_base::
  BasicEvent_base (const BasicEvent_base& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::fuzztree::InclusionVariationPoint (x, f, c),
    probability_ (x.probability_, f, this)
  {
  }

  BasicEvent_base::
  BasicEvent_base (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::fuzztree::InclusionVariationPoint (e, f | ::xml_schema::Flags::base, c),
    probability_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void BasicEvent_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::InclusionVariationPoint::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // probability
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "probability",
            "",
            &::xsd::cxx::tree::factory_impl< ProbabilityType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!probability_.present ())
          {
            ::std::auto_ptr< ProbabilityType > r (
              dynamic_cast< ProbabilityType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->probability_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!probability_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "probability",
        "");
    }
  }

  BasicEvent_base* BasicEvent_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BasicEvent_base (*this, f, c);
  }

  BasicEvent_base::
  ~BasicEvent_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, BasicEvent >
  _xsd_BasicEvent_type_factory_init (
    "BasicEvent",
    "net.fuzztree");

  // TopEvent_base
  //

  TopEvent_base::
  TopEvent_base (const IdType& id,
                 const MissionTimeType& missionTime)
  : ::fuzztree::Node (id),
    missionTime_ (missionTime, ::xml_schema::Flags (), this)
  {
  }

  TopEvent_base::
  TopEvent_base (const TopEvent_base& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::fuzztree::Node (x, f, c),
    missionTime_ (x.missionTime_, f, this)
  {
  }

  TopEvent_base::
  TopEvent_base (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::fuzztree::Node (e, f | ::xml_schema::Flags::base, c),
    missionTime_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TopEvent_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::Node::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "missionTime" && n.namespace_ ().empty ())
      {
        this->missionTime_.set (MissionTimeTraits::create (i, f, this));
        continue;
      }
    }

    if (!missionTime_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "missionTime",
        "");
    }
  }

  TopEvent_base* TopEvent_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TopEvent_base (*this, f, c);
  }

  TopEvent_base::
  ~TopEvent_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TopEvent >
  _xsd_TopEvent_type_factory_init (
    "TopEvent",
    "net.fuzztree");

  // And_base
  //

  And_base::
  And_base (const IdType& id)
  : ::fuzztree::Gate (id)
  {
  }

  And_base::
  And_base (const And_base& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fuzztree::Gate (x, f, c)
  {
  }

  And_base::
  And_base (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fuzztree::Gate (e, f, c)
  {
  }

  And_base* And_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class And_base (*this, f, c);
  }

  And_base::
  ~And_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, And >
  _xsd_And_type_factory_init (
    "And",
    "net.fuzztree");

  // Or_base
  //

  Or_base::
  Or_base (const IdType& id)
  : ::fuzztree::Gate (id)
  {
  }

  Or_base::
  Or_base (const Or_base& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::fuzztree::Gate (x, f, c)
  {
  }

  Or_base::
  Or_base (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::fuzztree::Gate (e, f, c)
  {
  }

  Or_base* Or_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Or_base (*this, f, c);
  }

  Or_base::
  ~Or_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Or >
  _xsd_Or_type_factory_init (
    "Or",
    "net.fuzztree");

  // Xor_base
  //

  Xor_base::
  Xor_base (const IdType& id)
  : ::fuzztree::Gate (id)
  {
  }

  Xor_base::
  Xor_base (const Xor_base& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fuzztree::Gate (x, f, c)
  {
  }

  Xor_base::
  Xor_base (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fuzztree::Gate (e, f, c)
  {
  }

  Xor_base* Xor_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Xor_base (*this, f, c);
  }

  Xor_base::
  ~Xor_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Xor >
  _xsd_Xor_type_factory_init (
    "Xor",
    "net.fuzztree");

  // VotingOr_base
  //

  VotingOr_base::
  VotingOr_base (const IdType& id,
                 const KType& k)
  : ::fuzztree::Gate (id),
    k_ (k, ::xml_schema::Flags (), this)
  {
  }

  VotingOr_base::
  VotingOr_base (const VotingOr_base& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::fuzztree::Gate (x, f, c),
    k_ (x.k_, f, this)
  {
  }

  VotingOr_base::
  VotingOr_base (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::fuzztree::Gate (e, f | ::xml_schema::Flags::base, c),
    k_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void VotingOr_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::Gate::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "k" && n.namespace_ ().empty ())
      {
        this->k_.set (KTraits::create (i, f, this));
        continue;
      }
    }

    if (!k_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "k",
        "");
    }
  }

  VotingOr_base* VotingOr_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VotingOr_base (*this, f, c);
  }

  VotingOr_base::
  ~VotingOr_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VotingOr >
  _xsd_VotingOr_type_factory_init (
    "VotingOr",
    "net.fuzztree");

  // FeatureVariationPoint_base
  //

  FeatureVariationPoint_base::
  FeatureVariationPoint_base (const IdType& id)
  : ::fuzztree::VariationPoint (id)
  {
  }

  FeatureVariationPoint_base::
  FeatureVariationPoint_base (const FeatureVariationPoint_base& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::fuzztree::VariationPoint (x, f, c)
  {
  }

  FeatureVariationPoint_base::
  FeatureVariationPoint_base (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::fuzztree::VariationPoint (e, f, c)
  {
  }

  FeatureVariationPoint_base* FeatureVariationPoint_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FeatureVariationPoint_base (*this, f, c);
  }

  FeatureVariationPoint_base::
  ~FeatureVariationPoint_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, FeatureVariationPoint >
  _xsd_FeatureVariationPoint_type_factory_init (
    "FeatureVariationPoint",
    "net.fuzztree");

  // RedundancyVariationPoint_base
  //

  RedundancyVariationPoint_base::
  RedundancyVariationPoint_base (const IdType& id,
                                 const StartType& start,
                                 const EndType& end,
                                 const FormulaType& formula)
  : ::fuzztree::VariationPoint (id),
    start_ (start, ::xml_schema::Flags (), this),
    end_ (end, ::xml_schema::Flags (), this),
    formula_ (formula, ::xml_schema::Flags (), this),
    costFormula_ (::xml_schema::Flags (), this)
  {
  }

  RedundancyVariationPoint_base::
  RedundancyVariationPoint_base (const RedundancyVariationPoint_base& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::fuzztree::VariationPoint (x, f, c),
    start_ (x.start_, f, this),
    end_ (x.end_, f, this),
    formula_ (x.formula_, f, this),
    costFormula_ (x.costFormula_, f, this)
  {
  }

  RedundancyVariationPoint_base::
  RedundancyVariationPoint_base (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::fuzztree::VariationPoint (e, f | ::xml_schema::Flags::base, c),
    start_ (f, this),
    end_ (f, this),
    formula_ (f, this),
    costFormula_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RedundancyVariationPoint_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::VariationPoint::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "start" && n.namespace_ ().empty ())
      {
        this->start_.set (StartTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "end" && n.namespace_ ().empty ())
      {
        this->end_.set (EndTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "formula" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< FormulaType > r (
          FormulaTraits::create (i, f, this));

        this->formula_.set (r);
        continue;
      }

      if (n.name () == "costFormula" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CostFormulaType > r (
          CostFormulaTraits::create (i, f, this));

        this->costFormula_.set (r);
        continue;
      }
    }

    if (!start_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "start",
        "");
    }

    if (!end_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "end",
        "");
    }

    if (!formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "formula",
        "");
    }
  }

  RedundancyVariationPoint_base* RedundancyVariationPoint_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RedundancyVariationPoint_base (*this, f, c);
  }

  RedundancyVariationPoint_base::
  ~RedundancyVariationPoint_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RedundancyVariationPoint >
  _xsd_RedundancyVariationPoint_type_factory_init (
    "RedundancyVariationPoint",
    "net.fuzztree");

  // TransferIn
  //

  TransferIn::
  TransferIn (const IdType& id,
              const FromModelIdType& fromModelId)
  : ::fuzztree::VariationPoint (id),
    fromModelId_ (fromModelId, ::xml_schema::Flags (), this),
    maxCosts_ (maxCostsDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  TransferIn::
  TransferIn (const TransferIn& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::fuzztree::VariationPoint (x, f, c),
    fromModelId_ (x.fromModelId_, f, this),
    maxCosts_ (x.maxCosts_, f, this)
  {
  }

  TransferIn::
  TransferIn (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::fuzztree::VariationPoint (e, f | ::xml_schema::Flags::base, c),
    fromModelId_ (f, this),
    maxCosts_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TransferIn::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::VariationPoint::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "fromModelId" && n.namespace_ ().empty ())
      {
        this->fromModelId_.set (FromModelIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxCosts" && n.namespace_ ().empty ())
      {
        this->maxCosts_.set (MaxCostsTraits::create (i, f, this));
        continue;
      }
    }

    if (!fromModelId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fromModelId",
        "");
    }

    if (!maxCosts_.present ())
    {
      this->maxCosts_.set (maxCostsDefaultValue ());
    }
  }

  TransferIn* TransferIn::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TransferIn (*this, f, c);
  }

  TransferIn::
  ~TransferIn ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransferIn >
  _xsd_TransferIn_type_factory_init (
    "TransferIn",
    "net.fuzztree");

  // Annotation
  //

  Annotation::
  Annotation ()
  : ::xml_schema::Type ()
  {
  }

  Annotation::
  Annotation (const Annotation& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  Annotation::
  Annotation (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f, c)
  {
  }

  Annotation::
  Annotation (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (a, f, c)
  {
  }

  Annotation::
  Annotation (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (s, e, f, c)
  {
  }

  Annotation* Annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Annotation (*this, f, c);
  }

  Annotation::
  ~Annotation ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Annotation >
  _xsd_Annotation_type_factory_init (
    "Annotation",
    "net.fuzztree");

  // Probability
  //

  Probability::
  Probability ()
  : ::xml_schema::Type ()
  {
  }

  Probability::
  Probability (const Probability& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  Probability::
  Probability (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f, c)
  {
  }

  Probability::
  Probability (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (a, f, c)
  {
  }

  Probability::
  Probability (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (s, e, f, c)
  {
  }

  Probability* Probability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Probability (*this, f, c);
  }

  Probability::
  ~Probability ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Probability >
  _xsd_Probability_type_factory_init (
    "Probability",
    "net.fuzztree");

  // CrispProbability
  //

  CrispProbability::
  CrispProbability (const ValueType& value)
  : ::fuzztree::Probability (),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  CrispProbability::
  CrispProbability (const CrispProbability& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::fuzztree::Probability (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  CrispProbability::
  CrispProbability (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::fuzztree::Probability (e, f | ::xml_schema::Flags::base, c),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void CrispProbability::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  CrispProbability* CrispProbability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CrispProbability (*this, f, c);
  }

  CrispProbability::
  ~CrispProbability ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CrispProbability >
  _xsd_CrispProbability_type_factory_init (
    "CrispProbability",
    "net.fuzztree");

  // FailureRate
  //

  FailureRate::
  FailureRate (const ValueType& value)
  : ::fuzztree::Probability (),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  FailureRate::
  FailureRate (const FailureRate& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::fuzztree::Probability (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  FailureRate::
  FailureRate (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::fuzztree::Probability (e, f | ::xml_schema::Flags::base, c),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void FailureRate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  FailureRate* FailureRate::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FailureRate (*this, f, c);
  }

  FailureRate::
  ~FailureRate ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, FailureRate >
  _xsd_FailureRate_type_factory_init (
    "FailureRate",
    "net.fuzztree");

  // TriangularFuzzyInterval
  //

  TriangularFuzzyInterval::
  TriangularFuzzyInterval (const AType& a,
                           const B1Type& b1,
                           const B2Type& b2,
                           const CType& c)
  : ::fuzztree::Probability (),
    a_ (a, ::xml_schema::Flags (), this),
    b1_ (b1, ::xml_schema::Flags (), this),
    b2_ (b2, ::xml_schema::Flags (), this),
    c_ (c, ::xml_schema::Flags (), this)
  {
  }

  TriangularFuzzyInterval::
  TriangularFuzzyInterval (const TriangularFuzzyInterval& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::fuzztree::Probability (x, f, c),
    a_ (x.a_, f, this),
    b1_ (x.b1_, f, this),
    b2_ (x.b2_, f, this),
    c_ (x.c_, f, this)
  {
  }

  TriangularFuzzyInterval::
  TriangularFuzzyInterval (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::fuzztree::Probability (e, f | ::xml_schema::Flags::base, c),
    a_ (f, this),
    b1_ (f, this),
    b2_ (f, this),
    c_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void TriangularFuzzyInterval::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "a" && n.namespace_ ().empty ())
      {
        this->a_.set (ATraits::create (i, f, this));
        continue;
      }

      if (n.name () == "b1" && n.namespace_ ().empty ())
      {
        this->b1_.set (B1Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "b2" && n.namespace_ ().empty ())
      {
        this->b2_.set (B2Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "c" && n.namespace_ ().empty ())
      {
        this->c_.set (CTraits::create (i, f, this));
        continue;
      }
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "a",
        "");
    }

    if (!b1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "b1",
        "");
    }

    if (!b2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "b2",
        "");
    }

    if (!c_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "c",
        "");
    }
  }

  TriangularFuzzyInterval* TriangularFuzzyInterval::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TriangularFuzzyInterval (*this, f, c);
  }

  TriangularFuzzyInterval::
  ~TriangularFuzzyInterval ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TriangularFuzzyInterval >
  _xsd_TriangularFuzzyInterval_type_factory_init (
    "TriangularFuzzyInterval",
    "net.fuzztree");

  // UndevelopedEvent_base
  //

  UndevelopedEvent_base::
  UndevelopedEvent_base (const IdType& id)
  : ::fuzztree::ChildNode (id)
  {
  }

  UndevelopedEvent_base::
  UndevelopedEvent_base (const UndevelopedEvent_base& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::fuzztree::ChildNode (x, f, c)
  {
  }

  UndevelopedEvent_base::
  UndevelopedEvent_base (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::fuzztree::ChildNode (e, f, c)
  {
  }

  UndevelopedEvent_base* UndevelopedEvent_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UndevelopedEvent_base (*this, f, c);
  }

  UndevelopedEvent_base::
  ~UndevelopedEvent_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, UndevelopedEvent >
  _xsd_UndevelopedEvent_type_factory_init (
    "UndevelopedEvent",
    "net.fuzztree");

  // IntermediateEvent_base
  //

  IntermediateEvent_base::
  IntermediateEvent_base (const IdType& id)
  : ::fuzztree::InclusionVariationPoint (id)
  {
  }

  IntermediateEvent_base::
  IntermediateEvent_base (const IntermediateEvent_base& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::fuzztree::InclusionVariationPoint (x, f, c)
  {
  }

  IntermediateEvent_base::
  IntermediateEvent_base (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::fuzztree::InclusionVariationPoint (e, f, c)
  {
  }

  IntermediateEvent_base* IntermediateEvent_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IntermediateEvent_base (*this, f, c);
  }

  IntermediateEvent_base::
  ~IntermediateEvent_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, IntermediateEvent >
  _xsd_IntermediateEvent_type_factory_init (
    "IntermediateEvent",
    "net.fuzztree");

  // BasicEventSet
  //

  BasicEventSet::
  BasicEventSet (const IdType& id,
                 const ProbabilityType& probability)
  : ::fuzztree::BasicEvent (id,
                            probability),
    quantity_ (::xml_schema::Flags (), this)
  {
  }

  BasicEventSet::
  BasicEventSet (const IdType& id,
                 ::std::auto_ptr< ProbabilityType >& probability)
  : ::fuzztree::BasicEvent (id,
                            probability),
    quantity_ (::xml_schema::Flags (), this)
  {
  }

  BasicEventSet::
  BasicEventSet (const BasicEventSet& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::fuzztree::BasicEvent (x, f, c),
    quantity_ (x.quantity_, f, this)
  {
  }

  BasicEventSet::
  BasicEventSet (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::fuzztree::BasicEvent (e, f | ::xml_schema::Flags::base, c),
    quantity_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void BasicEventSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::BasicEvent::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "quantity" && n.namespace_ ().empty ())
      {
        this->quantity_.set (QuantityTraits::create (i, f, this));
        continue;
      }
    }
  }

  BasicEventSet* BasicEventSet::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BasicEventSet (*this, f, c);
  }

  BasicEventSet::
  ~BasicEventSet ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, BasicEventSet >
  _xsd_BasicEventSet_type_factory_init (
    "BasicEventSet",
    "net.fuzztree");

  // HouseEvent_base
  //

  HouseEvent_base::
  HouseEvent_base (const IdType& id,
                   const ProbabilityType& probability)
  : ::fuzztree::BasicEvent (id,
                            probability)
  {
  }

  HouseEvent_base::
  HouseEvent_base (const IdType& id,
                   ::std::auto_ptr< ProbabilityType >& probability)
  : ::fuzztree::BasicEvent (id,
                            probability)
  {
  }

  HouseEvent_base::
  HouseEvent_base (const HouseEvent_base& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::fuzztree::BasicEvent (x, f, c)
  {
  }

  HouseEvent_base::
  HouseEvent_base (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::fuzztree::BasicEvent (e, f, c)
  {
  }

  HouseEvent_base* HouseEvent_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HouseEvent_base (*this, f, c);
  }

  HouseEvent_base::
  ~HouseEvent_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, HouseEvent >
  _xsd_HouseEvent_type_factory_init (
    "HouseEvent",
    "net.fuzztree");

  // IntermediateEventSet_base
  //

  IntermediateEventSet_base::
  IntermediateEventSet_base (const IdType& id)
  : ::fuzztree::IntermediateEvent (id),
    quantity_ (::xml_schema::Flags (), this)
  {
  }

  IntermediateEventSet_base::
  IntermediateEventSet_base (const IntermediateEventSet_base& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::fuzztree::IntermediateEvent (x, f, c),
    quantity_ (x.quantity_, f, this)
  {
  }

  IntermediateEventSet_base::
  IntermediateEventSet_base (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::fuzztree::IntermediateEvent (e, f | ::xml_schema::Flags::base, c),
    quantity_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void IntermediateEventSet_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::IntermediateEvent::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "quantity" && n.namespace_ ().empty ())
      {
        this->quantity_.set (QuantityTraits::create (i, f, this));
        continue;
      }
    }
  }

  IntermediateEventSet_base* IntermediateEventSet_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IntermediateEventSet_base (*this, f, c);
  }

  IntermediateEventSet_base::
  ~IntermediateEventSet_base ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, IntermediateEventSet >
  _xsd_IntermediateEventSet_type_factory_init (
    "IntermediateEventSet",
    "net.fuzztree");

  // EventSet
  //

  EventSet::
  EventSet (const IdType& id)
  : ::fuzztree::InclusionVariationPoint (id),
    quantity_ (::xml_schema::Flags (), this)
  {
  }

  EventSet::
  EventSet (const EventSet& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fuzztree::InclusionVariationPoint (x, f, c),
    quantity_ (x.quantity_, f, this)
  {
  }

  EventSet::
  EventSet (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fuzztree::InclusionVariationPoint (e, f | ::xml_schema::Flags::base, c),
    quantity_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void EventSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::fuzztree::InclusionVariationPoint::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "quantity" && n.namespace_ ().empty ())
      {
        this->quantity_.set (QuantityTraits::create (i, f, this));
        continue;
      }
    }
  }

  EventSet* EventSet::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EventSet (*this, f, c);
  }

  EventSet::
  ~EventSet ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EventSet >
  _xsd_EventSet_type_factory_init (
    "EventSet",
    "net.fuzztree");

  // DecomposedFuzzyProbability
  //

  DecomposedFuzzyProbability::
  DecomposedFuzzyProbability ()
  : ::fuzztree::Probability (),
    alphaCuts_ (::xml_schema::Flags (), this)
  {
  }

  DecomposedFuzzyProbability::
  DecomposedFuzzyProbability (const DecomposedFuzzyProbability& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::fuzztree::Probability (x, f, c),
    alphaCuts_ (x.alphaCuts_, f, this)
  {
  }

  DecomposedFuzzyProbability::
  DecomposedFuzzyProbability (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::fuzztree::Probability (e, f | ::xml_schema::Flags::base, c),
    alphaCuts_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DecomposedFuzzyProbability::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // alphaCuts
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "alphaCuts",
            "",
            &::xsd::cxx::tree::factory_impl< AlphaCutsType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< AlphaCutsType > r (
            dynamic_cast< AlphaCutsType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->alphaCuts_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  DecomposedFuzzyProbability* DecomposedFuzzyProbability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DecomposedFuzzyProbability (*this, f, c);
  }

  DecomposedFuzzyProbability::
  ~DecomposedFuzzyProbability ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DecomposedFuzzyProbability >
  _xsd_DecomposedFuzzyProbability_type_factory_init (
    "DecomposedFuzzyProbability",
    "net.fuzztree");

  // DoubleToIntervalMap
  //

  DoubleToIntervalMap::
  DoubleToIntervalMap (const ValueType& value,
                       const KeyType& key)
  : ::xml_schema::Type (),
    value_ (value, ::xml_schema::Flags (), this),
    key_ (key, ::xml_schema::Flags (), this)
  {
  }

  DoubleToIntervalMap::
  DoubleToIntervalMap (::std::auto_ptr< ValueType >& value,
                       const KeyType& key)
  : ::xml_schema::Type (),
    value_ (value, ::xml_schema::Flags (), this),
    key_ (key, ::xml_schema::Flags (), this)
  {
  }

  DoubleToIntervalMap::
  DoubleToIntervalMap (const DoubleToIntervalMap& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this),
    key_ (x.key_, f, this)
  {
  }

  DoubleToIntervalMap::
  DoubleToIntervalMap (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (f, this),
    key_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void DoubleToIntervalMap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "value",
            "",
            &::xsd::cxx::tree::factory_impl< ValueType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!value_.present ())
          {
            ::std::auto_ptr< ValueType > r (
              dynamic_cast< ValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->value_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "key" && n.namespace_ ().empty ())
      {
        this->key_.set (KeyTraits::create (i, f, this));
        continue;
      }
    }

    if (!key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key",
        "");
    }
  }

  DoubleToIntervalMap* DoubleToIntervalMap::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DoubleToIntervalMap (*this, f, c);
  }

  DoubleToIntervalMap::
  ~DoubleToIntervalMap ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DoubleToIntervalMap >
  _xsd_DoubleToIntervalMap_type_factory_init (
    "DoubleToIntervalMap",
    "net.fuzztree");

  // Interval
  //

  Interval::
  Interval (const LowerBoundType& lowerBound,
            const UpperBoundType& upperBound)
  : ::xml_schema::Type (),
    lowerBound_ (lowerBound, ::xml_schema::Flags (), this),
    upperBound_ (upperBound, ::xml_schema::Flags (), this)
  {
  }

  Interval::
  Interval (const Interval& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    lowerBound_ (x.lowerBound_, f, this),
    upperBound_ (x.upperBound_, f, this)
  {
  }

  Interval::
  Interval (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    lowerBound_ (f, this),
    upperBound_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Interval::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lowerBound" && n.namespace_ ().empty ())
      {
        this->lowerBound_.set (LowerBoundTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "upperBound" && n.namespace_ ().empty ())
      {
        this->upperBound_.set (UpperBoundTraits::create (i, f, this));
        continue;
      }
    }

    if (!lowerBound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lowerBound",
        "");
    }

    if (!upperBound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "upperBound",
        "");
    }
  }

  Interval* Interval::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Interval (*this, f, c);
  }

  Interval::
  ~Interval ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Interval >
  _xsd_Interval_type_factory_init (
    "Interval",
    "net.fuzztree");
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace fuzztree
{
  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (const ::std::string& u,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::fuzztree::FuzzTree > r (
      ::fuzztree::fuzzTree (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (const ::std::string& u,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fuzztree::FuzzTree > r (
      ::fuzztree::fuzzTree (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fuzztree::FuzzTree > r (
      ::fuzztree::fuzzTree (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::std::istream& is,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fuzztree::fuzzTree (isrc, f, p);
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::std::istream& is,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fuzztree::fuzzTree (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fuzztree::fuzzTree (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fuzztree::fuzzTree (isrc, f, p);
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fuzztree::fuzzTree (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fuzztree::fuzzTree (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::xercesc::InputSource& i,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::fuzztree::FuzzTree > r (
      ::fuzztree::fuzzTree (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::xercesc::InputSource& i,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fuzztree::FuzzTree > r (
      ::fuzztree::fuzzTree (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fuzztree::FuzzTree > r (
      ::fuzztree::fuzzTree (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (const ::xercesc::DOMDocument& d,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::fuzztree::FuzzTree > r (
        ::fuzztree::fuzzTree (
          c, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::xsd::cxx::tree::type_factory_map< char >& tfm (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

    ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
      tfm.create (
        "FuzzTree",
        "net.fuzztree",
        &::xsd::cxx::tree::factory_impl< ::fuzztree::FuzzTree >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::auto_ptr< ::fuzztree::FuzzTree > r (
        dynamic_cast< ::fuzztree::FuzzTree* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FuzzTree",
      "net.fuzztree");
  }

  ::std::auto_ptr< ::fuzztree::FuzzTree >
  fuzzTree (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    ::xsd::cxx::tree::type_factory_map< char >& tfm (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

    ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
      tfm.create (
        "FuzzTree",
        "net.fuzztree",
        &::xsd::cxx::tree::factory_impl< ::fuzztree::FuzzTree >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::auto_ptr< ::fuzztree::FuzzTree > r (
        dynamic_cast< ::fuzztree::FuzzTree* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FuzzTree",
      "net.fuzztree");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace fuzztree
{
  void
  operator<< (::xercesc::DOMElement& e, const AnnotatedElement& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // annotations
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AnnotatedElement::AnnotationsConstIterator
           b (i.annotations ().begin ()), n (i.annotations ().end ());
           b != n; ++b)
      {
        if (typeid (AnnotatedElement::AnnotationsType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "annotations",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "annotations",
            "",
            false, false, e, *b);
      }
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AnnotatedElement >
  _xsd_AnnotatedElement_type_serializer_init (
    "AnnotatedElement",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const Model& i)
  {
    e << static_cast< const ::fuzztree::AnnotatedElement& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Model >
  _xsd_Model_type_serializer_init (
    "Model",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const FuzzTree& i)
  {
    e << static_cast< const ::fuzztree::Model& > (i);

    // topEvent
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const FuzzTree::TopEventType& x (i.topEvent ());
      if (typeid (FuzzTree::TopEventType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "topEvent",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "topEvent",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FuzzTree >
  _xsd_FuzzTree_type_serializer_init (
    "FuzzTree",
    "net.fuzztree");


  void
  fuzzTree (::std::ostream& o,
            const ::fuzztree::FuzzTree& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fuzztree::fuzzTree (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  fuzzTree (::std::ostream& o,
            const ::fuzztree::FuzzTree& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fuzztree::fuzzTree (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  fuzzTree (::std::ostream& o,
            const ::fuzztree::FuzzTree& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fuzztree::fuzzTree (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  fuzzTree (::xercesc::XMLFormatTarget& t,
            const ::fuzztree::FuzzTree& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fuzztree::fuzzTree (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  fuzzTree (::xercesc::XMLFormatTarget& t,
            const ::fuzztree::FuzzTree& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fuzztree::fuzzTree (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  fuzzTree (::xercesc::XMLFormatTarget& t,
            const ::fuzztree::FuzzTree& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fuzztree::fuzzTree (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  fuzzTree (::xercesc::DOMDocument& d,
            const ::fuzztree::FuzzTree& s,
            ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::fuzztree::FuzzTree) == typeid (s))
    {
      if (n.name () == "FuzzTree" &&
          n.namespace_ () == "net.fuzztree")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "FuzzTree",
          "net.fuzztree");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      tsm.serialize (
        "FuzzTree",
        "net.fuzztree",
        e, n, s);
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  fuzzTree (const ::fuzztree::FuzzTree& s,
            const ::xml_schema::NamespaceInfomap& m,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::fuzztree::FuzzTree) == typeid (s))
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
        ::xsd::cxx::xml::dom::serialize< char > (
          "FuzzTree",
          "net.fuzztree",
          m, f));
      d = r;
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
        tsm.serialize (
          "FuzzTree",
          "net.fuzztree",
          m, s, f));
      d = r;
    }

    ::fuzztree::fuzzTree (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const Node_base& i)
  {
    e << static_cast< const ::fuzztree::AnnotatedElement& > (i);

    // children
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (Node_base::ChildrenConstIterator
           b (i.children ().begin ()), n (i.children ().end ());
           b != n; ++b)
      {
        if (typeid (Node_base::ChildrenType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "children",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "children",
            "",
            false, false, e, *b);
      }
    }

    // x
    //
    if (i.x ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << *i.x ();
    }

    // y
    //
    if (i.y ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << *i.y ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Node >
  _xsd_Node_type_serializer_init (
    "Node",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const ChildNode_base& i)
  {
    e << static_cast< const ::fuzztree::Node& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ChildNode >
  _xsd_ChildNode_type_serializer_init (
    "ChildNode",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const Gate_base& i)
  {
    e << static_cast< const ::fuzztree::ChildNode& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Gate >
  _xsd_Gate_type_serializer_init (
    "Gate",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const VariationPoint_base& i)
  {
    e << static_cast< const ::fuzztree::ChildNode& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VariationPoint >
  _xsd_VariationPoint_type_serializer_init (
    "VariationPoint",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const InclusionVariationPoint& i)
  {
    e << static_cast< const ::fuzztree::VariationPoint& > (i);

    // optional
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "optional",
          e));

      a << i.optional ();
    }

    // costs
    //
    if (i.costs ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "costs",
          e));

      a << *i.costs ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InclusionVariationPoint >
  _xsd_InclusionVariationPoint_type_serializer_init (
    "InclusionVariationPoint",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const BasicEvent_base& i)
  {
    e << static_cast< const ::fuzztree::InclusionVariationPoint& > (i);

    // probability
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const BasicEvent_base::ProbabilityType& x (i.probability ());
      if (typeid (BasicEvent_base::ProbabilityType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "probability",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "probability",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BasicEvent >
  _xsd_BasicEvent_type_serializer_init (
    "BasicEvent",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const TopEvent_base& i)
  {
    e << static_cast< const ::fuzztree::Node& > (i);

    // missionTime
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "missionTime",
          e));

      a << i.missionTime ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TopEvent >
  _xsd_TopEvent_type_serializer_init (
    "TopEvent",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const And_base& i)
  {
    e << static_cast< const ::fuzztree::Gate& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, And >
  _xsd_And_type_serializer_init (
    "And",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const Or_base& i)
  {
    e << static_cast< const ::fuzztree::Gate& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Or >
  _xsd_Or_type_serializer_init (
    "Or",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const Xor_base& i)
  {
    e << static_cast< const ::fuzztree::Gate& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Xor >
  _xsd_Xor_type_serializer_init (
    "Xor",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const VotingOr_base& i)
  {
    e << static_cast< const ::fuzztree::Gate& > (i);

    // k
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "k",
          e));

      a << i.k ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VotingOr >
  _xsd_VotingOr_type_serializer_init (
    "VotingOr",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const FeatureVariationPoint_base& i)
  {
    e << static_cast< const ::fuzztree::VariationPoint& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FeatureVariationPoint >
  _xsd_FeatureVariationPoint_type_serializer_init (
    "FeatureVariationPoint",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const RedundancyVariationPoint_base& i)
  {
    e << static_cast< const ::fuzztree::VariationPoint& > (i);

    // start
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "start",
          e));

      a << i.start ();
    }

    // end
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "end",
          e));

      a << i.end ();
    }

    // formula
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formula",
          e));

      a << i.formula ();
    }

    // costFormula
    //
    if (i.costFormula ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "costFormula",
          e));

      a << *i.costFormula ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RedundancyVariationPoint >
  _xsd_RedundancyVariationPoint_type_serializer_init (
    "RedundancyVariationPoint",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const TransferIn& i)
  {
    e << static_cast< const ::fuzztree::VariationPoint& > (i);

    // fromModelId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fromModelId",
          e));

      a << i.fromModelId ();
    }

    // maxCosts
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxCosts",
          e));

      a << i.maxCosts ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransferIn >
  _xsd_TransferIn_type_serializer_init (
    "TransferIn",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const Annotation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Annotation&)
  {
  }

  void
  operator<< (::xml_schema::ListStream&,
              const Annotation&)
  {
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Annotation >
  _xsd_Annotation_type_serializer_init (
    "Annotation",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const Probability& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Probability&)
  {
  }

  void
  operator<< (::xml_schema::ListStream&,
              const Probability&)
  {
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Probability >
  _xsd_Probability_type_serializer_init (
    "Probability",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const CrispProbability& i)
  {
    e << static_cast< const ::fuzztree::Probability& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::AsDouble(i.value ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CrispProbability >
  _xsd_CrispProbability_type_serializer_init (
    "CrispProbability",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const FailureRate& i)
  {
    e << static_cast< const ::fuzztree::Probability& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::AsDouble(i.value ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FailureRate >
  _xsd_FailureRate_type_serializer_init (
    "FailureRate",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const TriangularFuzzyInterval& i)
  {
    e << static_cast< const ::fuzztree::Probability& > (i);

    // a
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "a",
          e));

      a << ::xml_schema::AsDouble(i.a ());
    }

    // b1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "b1",
          e));

      a << ::xml_schema::AsDouble(i.b1 ());
    }

    // b2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "b2",
          e));

      a << ::xml_schema::AsDouble(i.b2 ());
    }

    // c
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "c",
          e));

      a << ::xml_schema::AsDouble(i.c ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TriangularFuzzyInterval >
  _xsd_TriangularFuzzyInterval_type_serializer_init (
    "TriangularFuzzyInterval",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const UndevelopedEvent_base& i)
  {
    e << static_cast< const ::fuzztree::ChildNode& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UndevelopedEvent >
  _xsd_UndevelopedEvent_type_serializer_init (
    "UndevelopedEvent",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const IntermediateEvent_base& i)
  {
    e << static_cast< const ::fuzztree::InclusionVariationPoint& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IntermediateEvent >
  _xsd_IntermediateEvent_type_serializer_init (
    "IntermediateEvent",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const BasicEventSet& i)
  {
    e << static_cast< const ::fuzztree::BasicEvent& > (i);

    // quantity
    //
    if (i.quantity ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "quantity",
          e));

      a << *i.quantity ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BasicEventSet >
  _xsd_BasicEventSet_type_serializer_init (
    "BasicEventSet",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const HouseEvent_base& i)
  {
    e << static_cast< const ::fuzztree::BasicEvent& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HouseEvent >
  _xsd_HouseEvent_type_serializer_init (
    "HouseEvent",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const IntermediateEventSet_base& i)
  {
    e << static_cast< const ::fuzztree::IntermediateEvent& > (i);

    // quantity
    //
    if (i.quantity ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "quantity",
          e));

      a << *i.quantity ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IntermediateEventSet >
  _xsd_IntermediateEventSet_type_serializer_init (
    "IntermediateEventSet",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const EventSet& i)
  {
    e << static_cast< const ::fuzztree::InclusionVariationPoint& > (i);

    // quantity
    //
    if (i.quantity ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "quantity",
          e));

      a << *i.quantity ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EventSet >
  _xsd_EventSet_type_serializer_init (
    "EventSet",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const DecomposedFuzzyProbability& i)
  {
    e << static_cast< const ::fuzztree::Probability& > (i);

    // alphaCuts
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (DecomposedFuzzyProbability::AlphaCutsConstIterator
           b (i.alphaCuts ().begin ()), n (i.alphaCuts ().end ());
           b != n; ++b)
      {
        if (typeid (DecomposedFuzzyProbability::AlphaCutsType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "alphaCuts",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "alphaCuts",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DecomposedFuzzyProbability >
  _xsd_DecomposedFuzzyProbability_type_serializer_init (
    "DecomposedFuzzyProbability",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const DoubleToIntervalMap& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // value
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const DoubleToIntervalMap::ValueType& x (i.value ());
      if (typeid (DoubleToIntervalMap::ValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "value",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "value",
          "",
          false, false, e, x);
    }

    // key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "key",
          e));

      a << ::xml_schema::AsDouble(i.key ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DoubleToIntervalMap >
  _xsd_DoubleToIntervalMap_type_serializer_init (
    "DoubleToIntervalMap",
    "net.fuzztree");


  void
  operator<< (::xercesc::DOMElement& e, const Interval& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // lowerBound
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "lowerBound",
          e));

      a << ::xml_schema::AsDouble(i.lowerBound ());
    }

    // upperBound
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "upperBound",
          e));

      a << ::xml_schema::AsDouble(i.upperBound ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Interval >
  _xsd_Interval_type_serializer_init (
    "Interval",
    "net.fuzztree");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

