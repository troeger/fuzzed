import json
import logging

from django import http
from django.core.exceptions import ObjectDoesNotExist, MultipleObjectsReturned
from django.core.urlresolvers import reverse
from tastypie.authentication import SessionAuthentication
from tastypie.bundle import Bundle
from tastypie.http import HttpApplicationError, HttpAccepted
from tastypie import fields
from django.core.mail import mail_managers

from FuzzEd.models import Job, Graph
import common


logger = logging.getLogger('FuzzEd')


class JobResource(common.JobResource):
    """
        An API resource for jobs.
        Jobs look different for the JS client than they look for the backend,
        so we have a custom implementation here.
    """

    class Meta:
        queryset = Job.objects.all()
        authorization = common.GraphOwnerAuthorization()
        authentication = SessionAuthentication()
        list_allowed_methods = ['post']
        detail_allowed_methods = ['get']

    graph = fields.ToOneField('FuzzEd.api.common.GraphResource', 'graph')

    def get_resource_uri(self, bundle_or_obj=None, url_name='api_dispatch_list'):
        """
            Since we change the API URL format to nested resources, we need also to
            change the location determination for a given resource object.
        """
        job_secret = bundle_or_obj.obj.secret
        graph_pk = bundle_or_obj.obj.graph.pk
        return reverse('job', kwargs={'api_name': 'front', 'pk': graph_pk, 'secret': job_secret})

    def obj_create(self, bundle, **kwargs):
        """
            Create a new job for the given graph.
            The request body contains the information about the kind of job being requested.
            The result is a job URL that is based on the generated job secret.
            This is the only override that allows us to access 'kwargs', which contains the
            graph_id from the original request.
        """
        graph = Graph.objects.get(pk=kwargs['graph_id'], deleted=False)
        bundle.data['graph'] = graph
        bundle.data['graph_modified'] = graph.modified
        bundle.data['kind'] = bundle.data['kind']
        bundle.obj = self._meta.object_class()
        bundle = self.full_hydrate(bundle)
        return self.save(bundle)

    def get_detail(self, request, **kwargs):
        """
            Called by the request dispatcher in case somebody tries to GET a job resource.
            For the frontend, deliver the current job status if pending, or the result.
        """
        basic_bundle = self.build_bundle(request=request)
        try:
            job = self.cached_obj_get(bundle=basic_bundle, **self.remove_api_resource_names(kwargs))
        except ObjectDoesNotExist:
            return http.HttpNotFound()
        except MultipleObjectsReturned:
            return http.HttpMultipleChoices("More than one resource is found at this URI.")

        if job.done():
            if job.exit_code == 0:
                return job.as_http_response()
            else:
                logger.debug("Job is done, but with non-zero exit code.")
                mail_managers('Analysis of job %s ended with non-zero exit code.' % job.pk, job.graph.to_xml())
                return HttpApplicationError()
        else:
            # Job is pending, tell this by HTTP return code
            return HttpAccepted()

    def apply_authorization_limits(self, request, object_list):
        # Prevent cross-checking of jobs by different users
        return object_list.filter(graph__owner=request.user)


class NotificationResource(common.NotificationResource):
    class Meta(common.NotificationResource.Meta):
        authentication = SessionAuthentication()


class NodeResource(common.NodeResource):
    class Meta(common.NodeResource.Meta):
        authentication = SessionAuthentication()


class NodeGroupResource(common.NodeGroupResource):
    class Meta(common.NodeGroupResource.Meta):
        authentication = SessionAuthentication()


class EdgeResource(common.EdgeResource):
    class Meta(common.EdgeResource.Meta):
        authentication = SessionAuthentication()


class ProjectResource(common.ProjectResource):
    class Meta(common.ProjectResource.Meta):
        authentication = SessionAuthentication()


class GraphSerializer(common.GraphSerializer):
    """
        The frontend gets its own JSON format for the graph information,
        not the default HATEOAS format generated by Tastypie. For this reason,
        we need a frontend API specific JSON serializer.
    """

    def to_json(self, data, options=None):
        if isinstance(data, Bundle):
            return data.obj.to_json()
        elif isinstance(data, dict):
            if 'objects' in data:               # object list
                graphs = []
                for graph in data['objects']:
                    graphs.append({'url': reverse('graph', kwargs={'api_name': 'front', 'pk': graph.obj.pk}),
                                   'name': graph.obj.name})
                return json.dumps({'graphs': graphs})
            else:
                # Traceback error message, instead of a result
                return json.dumps(data)


class GraphResource(common.GraphResource):
    """
        Override our GraphResource Meta class to register the custom
        frontend JSON serializer and the frontent auth method.
        This version also configures the dispatching to the nested resource implementations in this file.
    """

    class Meta(common.GraphResource.Meta):
        authentication = SessionAuthentication()
        serializer = GraphSerializer()

    def dispatch_edges(self, request, **kwargs):
        edge_resource = EdgeResource()
        return edge_resource.dispatch_list(request, graph_id=kwargs['pk'])

    def dispatch_edge(self, request, **kwargs):
        edge_resource = EdgeResource()
        return edge_resource.dispatch_detail(request, graph_id=kwargs['pk'], client_id=kwargs['client_id'])

    def dispatch_nodes(self, request, **kwargs):
        node_resource = NodeResource()
        return node_resource.dispatch_list(request, graph_id=kwargs['pk'])

    def dispatch_node(self, request, **kwargs):
        node_resource = NodeResource()
        return node_resource.dispatch_detail(request, graph_id=kwargs['pk'], client_id=kwargs['client_id'])

    def dispatch_nodegroups(self, request, **kwargs):
        nodegroup_resource = NodeGroupResource()
        return nodegroup_resource.dispatch_list(request, graph_id=kwargs['pk'])

    def dispatch_nodegroup(self, request, **kwargs):
        nodegroup_resource = NodeGroupResource()
        return nodegroup_resource.dispatch_detail(request, graph_id=kwargs['pk'], client_id=kwargs['client_id'])

    def dispatch_jobs(self, request, **kwargs):
        job_resource = JobResource()
        return job_resource.dispatch_list(request, graph_id=kwargs['pk'])

    def dispatch_job(self, request, **kwargs):
        job_resource = JobResource()
        return job_resource.dispatch_detail(request, graph_id=kwargs['pk'], secret=kwargs['secret'])

