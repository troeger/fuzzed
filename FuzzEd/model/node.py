from django.db import models
from django.core.exceptions import ObjectDoesNotExist

from graph import Graph

import notations

class Node(models.Model):
    """
    Class: Node

    This class models a generic node for any diagram notation.

    Fields:
    {long} client_id - an id for this node that is generated by the client
    {string} kind - a unique identifier for the kind of the node in its notation - e.g. "choice" for FuzzTrees. Must be in the set of available node kinds of the owning graph's notation
    {<Graph>} graph - the graph that owns the node
    {int} x - the x coordinate of the node (default: 0)
    {int} y - the y coordinate of the node (default: 0) 
    {bool} deleted - flag indicating whether this node is deleted. Simpilifies restoration of nodes by toggling the flag (default: False)
    """
    class Meta:
        app_label = 'FuzzEd'

    # root nodes always get the ID 0, do not reassign
    client_id = models.BigIntegerField(default=0)
    kind      = models.CharField(max_length=127, choices=notations.node_choices)
    graph     = models.ForeignKey(Graph, null=False, related_name='nodes')
    x         = models.IntegerField(default=0)
    y         = models.IntegerField(default=0)
    deleted   = models.BooleanField(default=False)

    def __unicode__(self):
        try:
            return Property.objects.get(node=self, key='name').value

        except ObjectDoesNotExist:
            return '%s_%s' % (notations.by_kind[graph.kind]['nodes'][kind]['name'], self.pk)

    def to_json(self):
        """
        Method: to_json
        
        Serializes the values of this node into a python dictionary that is JSON conform.

        Returns:
        {dict}
        """
        serialized = dict([prop.to_tuple() for prop in self.properties.filter(deleted=False)])

        serialized['id']            = self.client_id
        serialized['kind']          = self.kind
        serialized['outgoingEdges'] = [edge.to_json() for edge in self.outgoing.filter(deleted=False)]

        return serialized

    def get_children(self):
        """
        Method: get_children
        
        Retrieves all nodes that are directly or transitively targets of edges that origin from this node. The nodes are encoded as dictionaries as generated by <get_tree()>. If there are no edges present then None is returned.

        Returns:
        {list(dict)}
        """
        edges = self.outgoing.filter(deleted=False)

        if edges:
            return [edge.target.get_tree() for edge in edges]
        return None

    def get_tree(self):
        """
        Method: get_tree
        
        Serializes this node into nested dictionaries that represent the tree whichs root is the node itself.

        Returns:
        {dict}
        """
        return {
            'id':       self.pk,
            'name':     unicode(self),
            'children': self.get_children()
        }

# the handler will ensure that the kind of the node is present in its containing graph notation
def validate_kind(sender, instance, **kwargs):
    graph = instance.graph
    if not instance.kind in notations.by_kind[graph.kind]['nodes']:
        raise ValueError('Graph %s does not support nodes of type %s' % (graph, instance.kind))

# register a django handler for all node instances that calls the validator before each save
models.signals.pre_save.connect(validate_kind, sender=Node)

# ensures that the validate handler is not exported
__all__ = ['Node']